给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**

**输入：** nums = `[1,3,4,2,2]`
**输出：** 2

**示例 2：**

**输入：** nums =` [3,1,3,4,2]`
**输出：** 3

**示例 3 :**

**输入：** `nums = [3,3,3,3,3]`
**输出：** 3

**提示：**

- `1 <= n <= 105`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次** 


##### 解法

一个非常巧妙的解法是对**数字的范围**而不是数组的索引进行**二分查找**。其核心思想是**抽屉原理**（Pigeonhole Principle）。

**抽屉原理**：如果每个抽屉代表一个数字，每个元素代表一个苹果。现在有 n+1 个苹果要放到 n 个抽屉里，则至少有一个抽屉里会有两个苹果。

1. **确定搜索范围**：数字的范围是 [1, n]，所以我们初始化 left = 1, right = n。

2. **进行二分查找**：

- 计算中间数 mid = (left + right) // 2。

3. **遍历整个数组**，统计所有**小于等于** mid 的数字的个数 count。

4. **判断并缩小区间**（这是最关键的一步）：

- 如果 count <= mid：

- 说明 [1, mid] 这个区间内的数字“没有超额”，所有重复数字都正常出现了。

- 根据抽屉原理，重复数必然在 [mid+1, right] 这个更大的区间里。

- 调整左边界：left = mid + 1。

- 如果 count > mid：

- 说明 [1, mid] 这个区间内的数字“出现了超额”，重复数必然存在于这个区间内。

- 调整右边界：right = mid（注意：mid 本身有可能是重复数，所以不能跳过）。

5. **循环结束**：当 left == right 时，它们所指向的数字就是我们要找的重复数。
##### 代码
```javascript
var findDuplicate = function(nums) {
    const n = nums.length - 1
    let left = 1, right = n
    while(left < right) {
        let mid = Math.floor((left + right) / 2), count = 0
        for(let i = 0; i <= n; i++) {
            if (nums[i] <= mid) {
                count++
            }
        }
        if (count <= mid) {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
};
```